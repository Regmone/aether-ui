{
  "readme_content": "# Aether-UI: Cross-Chain Bridge Oracle Simulator\n\nAether-UI is a Python-based simulation of a cross-chain bridge oracle. It demonstrates the architecture and core logic of a service that listens for events on a source blockchain and triggers corresponding actions on a destination chain, specifically simulating a \"lock-and-mint\" style bridge.\n\n## Concept\n\nIn a decentralized ecosystem with multiple blockchains, cross-chain bridges are essential for transferring assets and data. A common bridge model is \"lock-and-mint\":\n\n1.  **Lock/Deposit:** A user deposits an asset (e.g., an ERC20 token) into a smart contract on the source chain (e.g., Ethereum).\n2.  **Event Emission:** The source chain contract emits an event (e.g., `AssetDeposited`) containing details of the deposit, such as the recipient address and amount.\n3.  **Oracle Listening:** A network of off-chain services, known as oracles or validators, listens for these events.\n4.  **Verification:** After waiting for a certain number of block confirmations to ensure the deposit is final and not part of a chain reorganization, the oracles agree on the event's validity.\n5.  **Mint/Release:** An oracle submits a transaction to a smart contract on the destination chain (e.g., Polygon), authorizing it to mint a corresponding wrapped asset (e.g., wERC20) and send it to the user's recipient address.\n\nThis script simulates the role of a single oracle (Steps 3-5), providing a robust foundation for building a real-world, decentralized bridge validator.\n\n## Code Architecture\n\nThe script is designed with a clear separation of concerns, using distinct classes for different responsibilities. This makes the code modular, testable, and easier to maintain.\n\n-   `ConfigManager`:\n    -   **Responsibility**: Loads all necessary configuration from a `.env` file.\n    -   **Details**: It fetches RPC URLs, contract addresses, the oracle's private key, and operational parameters like block confirmations. It includes validation to ensure all critical settings are present at startup.\n\n-   `BlockchainConnector`:\n    -   **Responsibility**: Manages the connection to a blockchain via a Web3 provider.\n    -   **Details**: It abstracts the `Web3.py` connection logic. It is instantiated separately for the source and destination chains and handles common requirements like injecting Proof-of-Authority (PoA) middleware for testnets.\n\n-   `EventScanner`:\n    -   **Responsibility**: Scans the source blockchain for new smart contract events.\n    -   **Details**: It keeps track of the last block it scanned in a state file (`last_scanned_block.json`) to prevent re-processing events and ensure continuity across restarts. It scans a range of blocks from the last scanned block up to the latest block minus a confirmation delay.\n\n-   `TransactionProcessor`:\n    -   **Responsibility**: Constructs, signs, and sends transactions to the destination chain.\n    -   **Details**: It takes a confirmed event from the `EventScanner`, formats the data for the destination contract's `mint` function, manages the account's nonce to prevent transaction failures, and submits the transaction to the network.\n\n-   `BridgeOracle`:\n    -   **Responsibility**: The main orchestrator class that integrates all components.\n    -   **Details**: It initializes all other components and runs the main application loop. The loop periodically instructs the `EventScanner` to check for new events and, if any are found, passes them to the `TransactionProcessor` for handling.\n\n## How it Works\n\nThe operational flow of the script is as follows:\n\n1.  **Initialization**: On startup, the `BridgeOracle` class is instantiated.\n    -   The `ConfigManager` loads and validates the environment configuration.\n    -   Two `BlockchainConnector` instances are created: one for the source chain and one for the destination chain.\n    -   The `EventScanner` is initialized with the source chain connector and contract details.\n    -   The `TransactionProcessor` is initialized with the destination chain connector and the oracle's signing key.\n\n2.  **Main Loop**: The `run()` method starts an infinite loop.\n\n3.  **Scanning**: In each iteration, the `EventScanner.scan_for_events()` method is called.\n    -   It reads the `last_scanned_block.json` file to know where to start scanning.\n    -   It determines the `to_block` by taking the latest block number from the source chain and subtracting the `REQUIRED_CONFIRMATIONS` value. This prevents acting on events that might be reverted in a chain reorganization.\n    -   It queries the source chain RPC for `AssetDeposited` events within this block range.\n\n4.  **Processing**: If the scanner returns new events:\n    -   The script iterates through each event.\n    -   For each event, it calls `TransactionProcessor.process_deposit_event()`.\n    -   The processor uses the unique `sourceTxHash` from the event to check if a mint transaction for this specific deposit has already been submitted. This is a crucial safeguard against processing the same deposit event more than once.\n    -   It builds a `mint` transaction, signs it with the oracle's private key, and sends it to the destination chain.\n    -   It logs the resulting transaction hash.\n\n5.  **State Update**: After scanning, the `EventScanner` updates the `last_scanned_block.json` file with the `to_block` number, ensuring the next scan cycle resumes from the correct block.\n\n6.  **Wait**: The script then pauses for the duration specified by `SCAN_INTERVAL_SECONDS` before starting the loop again.\n\n## Smart Contract Assumptions\n\nThe oracle is designed to interact with smart contracts that follow a specific interface.\n\n-   **Source Contract Event**: It is designed to listen for an `AssetDeposited` event with the following structure:\n    ```solidity\n    // Example from a Solidity contract\n    event AssetDeposited(address recipient, uint256 amount, bytes32 sourceTxHash);\n    ```\n-   **Destination Contract Function**: It calls a `mint` function on the destination contract with the following signature:\n    ```solidity\n    // Example from a Solidity contract\n    function mint(address recipient, uint256 amount, bytes32 sourceTxHash) external;\n    ```\n\n## Usage\n\n### 1. Prerequisites\n\n-   Python 3.8+\n-   Access to RPC endpoints for two EVM-compatible blockchains (e.g., from Infura, Alchemy, or a local node).\n-   An account with funds on the destination chain to pay for gas fees.\n\n### 2. Setup\n\n-   Clone the repository:\n    ```bash\n    git clone https://github.com/your-username/aether-ui.git\n    cd aether-ui\n    ```\n\n-   Create a virtual environment and install dependencies:\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows, use `venv\\Scripts\\activate`\n    pip install -r requirements.txt\n    ```\n\n-   Create a `.env` file by copying the example template:\n    ```bash\n    cp .env.example .env\n    ```\n    Then, open the `.env` file in your editor and fill in your specific values:\n    ```dotenv\n    # --- SOURCE CHAIN (e.g., Ethereum Sepolia) ---\n    SOURCE_CHAIN_RPC=\"https://sepolia.infura.io/v3/YOUR_INFURA_PROJECT_ID\"\n    SOURCE_BRIDGE_CONTRACT_ADDRESS=\"0x..._Source_Contract_Address_...\"\n\n    # --- DESTINATION CHAIN (e.g., Polygon Mumbai) ---\n    DEST_CHAIN_RPC=\"https://polygon-mumbai.g.alchemy.com/v2/YOUR_ALCHEMY_API_KEY\"\n    DEST_BRIDGE_CONTRACT_ADDRESS=\"0x..._Destination_Contract_Address_...\"\n\n    # --- ORACLE CONFIGURATION ---\n    # IMPORTANT: Do NOT commit this file with a real private key. Use a dedicated, low-value account for testing.\n    ORACLE_PRIVATE_KEY=\"your_oracle_account_private_key_without_0x\"\n\n    # --- OPERATIONAL PARAMETERS ---\n    # Number of blocks to wait on the source chain before considering an event confirmed\n    REQUIRED_CONFIRMATIONS=12\n    # Time in seconds between each scan cycle\n    SCAN_INTERVAL_SECONDS=30\n    # File to store the last processed block number\n    STATE_FILE=\"last_scanned_block.json\"\n    ```\n\n### 3. Run the Oracle\n\nStarting the oracle is straightforward.\n\n-   Run the main script from your terminal:\n    ```bash\n    python main.py\n    ```\n\n-   The oracle will start running, and you will see log output in your console as it scans for and processes events:\n    ```log\n    2023-10-27 14:30:00 - INFO - [config_manager.validate_config] - Configuration loaded and validated successfully.\n    2023-10-27 14:30:01 - INFO - [blockchain_connector._connect] - Connecting to blockchain via RPC: https://sepolia.infura.io/v3/...\n    2023-10-27 14:30:02 - INFO - [blockchain_connector._connect] - Successfully connected. Chain ID: 11155111\n    2023-10-27 14:30:02 - INFO - [blockchain_connector._connect] - Connecting to blockchain via RPC: https://polygon-mumbai.g.alchemy.com/v2/...\n    2023-10-27 14:30:03 - INFO - [blockchain_connector._connect] - Successfully connected. Chain ID: 80001\n    2023-10-27 14:30:03 - INFO - [transaction_processor.__init__] - Transaction processor initialized for account: 0xYourOracleAccountAddress\n    2023-10-27 14:30:03 - INFO - [bridge_oracle.run] - Aether-UI Bridge Oracle starting up...\n    2023-10-27 14:30:03 - INFO - [bridge_oracle.run] - Watching for 'AssetDeposited' events on contract 0x..._Source_Contract_Address_...\n    2023-10-27 14:30:03 - INFO - [bridge_oracle.run] - Will submit 'mint' transactions to 0x..._Destination_Contract_Address_...\n    2023-10-27 14:30:04 - INFO - [event_scanner.scan_for_events] - Scanning for 'AssetDeposited' events from block 4850123 to 4850220...\n    2023-10-27 14:30:05 - INFO - [event_scanner.scan_for_events] - Found 1 new 'AssetDeposited' event.\n    2023-10-27 14:30:05 - INFO - [bridge_oracle.run] - Processing 1 new event.\n    2023-10-27 14:30:05 - INFO - [transaction_processor.process_deposit_event] - Processing deposit: 1000000000000000000 tokens for 0x...UserAddress... from source tx 0x...source_tx_hash...\n    2023-10-27 14:30:06 - INFO - [transaction_processor.process_deposit_event] - Submitted mint transaction to destination chain. Tx Hash: 0x...destination_tx_hash...\n    2023-10-27 14:30:35 - INFO - [event_scanner.scan_for_events] - No new events found. Waiting for next cycle...\n    ```\n\n## 🛡️ Security Note\n\nThis project handles a private key to sign transactions, making security paramount. It is critical to ensure this key is never exposed.\n\n-   **NEVER** commit your `.env` file or expose your private key in a public repository.\n-   For testing and development, always use a dedicated account with a small, non-critical amount of funds.\n-   Ensure your project's `.gitignore` file includes `.env` to prevent accidental commits.\n\n    ```gitignore\n    # Environment variables\n    .env\n\n    # Python virtual environment\n    venv/\n    __pycache__/\n    *.pyc\n    ```"
}